TODO

User Designer Developer

1. max_lot, min_lat, x_res, y_res from plpython (not mentioned in RasSparql and not in mappings)
2. automate the mappings for geometry based raster searching
3. DecTables 
4. Lookup Table needs to be more robust
5. 


-- Regions: Deggendorf .
-- Raster Baveria_Temperature_MODIS_1km --
-- xmin = 8.979166665862266  
-- ymax = 50.56666666213664 
-- pixel_size = 0.008333333332587


-- Regions: Linköping.
-- Raster Surface_Temperature_Sweden --
-- xmin = 10.958333332351629  
-- ymax = 69.06666666047931 
-- pixel_size = 0.008333333332586788


-- Regions: Ultimo. 
-- Raster South_Tyrol_Temperature_MODIS_1km --
-- xmin = 10.38333333240314  
-- ymax = 47.099999995780536 
-- pixel_size = 0.008333333332586793


-- Regions of Interest (ROI)


shp2pgsql -s 4326 /home/arkaghosh/Downloads/Bolzano/Vector/South_Tyrol_LOD3.shp region_South_Tyrol | psql -h localhost -p 5432 -U postgres -d VectorDB 

shp2pgsql -s 4326 /home/arkaghosh/Downloads/Baveria/Vector/Baveria_1.shp region_bavaria | psql -h localhost -p 5432 -U postgres -d VectorDB

shp2pgsql -s 4326 /home/arkaghosh/Downloads/OntoRaster/Vector/Districts_India.shp region_India | psql -h localhost -p 5432 -U postgres -d VectorDB


SELECT * FROM public.region_sweden
WHERE name_2 LIKE '%Ume%';

SELECT * FROM public.region_sweden
WHERE name_2 LIKE '%Göteborg%';

SELECT * FROM public.region_south_tyrol
WHERE name_3 LIKE '%Bolzano%';

CREATE OR REPLACE VIEW Four_Regions AS
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Deggendorf'
UNION
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'München'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Linköping'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Ultimo'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Stockholm'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Bolzano';



-- Fetch raster data name based on vector region name
SELECT  m.name_2 AS region,ST_XMax(ST_GeomFromText(geom))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- Xmin and min_long
SELECT  m.name_2 AS region, ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

-- Ymax and max_lat
SELECT  m.name_2 AS region, ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))) as max_lat_V
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

-- BBOX
SELECT  m.name_2 AS region, ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT DISTINCT coverage_id as raster_name
FROM lookup_main
WHERE max_lat > (SELECT  ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
				 FROM    region_sweden as m
				 WHERE   m.name_2 = 'Linköping') AND min_lat < (SELECT  ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
															      FROM    region_sweden as m
																  WHERE   m.name_2 = 'Linköping') AND max_long > (SELECT  ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																												    FROM    region_sweden as m
																													WHERE   m.name_2 = 'Linköping') AND min_long < (SELECT  ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																																									  FROM    region_sweden as m
																																									  WHERE   m.name_2 = 'Linköping')

																																									  



	
-- Custom Table that hold all regions of three different raster

CREATE VIEW Four_Regions AS
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Deggendorf'
UNION
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Regen'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Linköping'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Ultimo';


SELECT DISTINCT coverage_id as raster_name
FROM lookup_main
WHERE max_lat > (SELECT  ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
				 FROM    four_regions as m
				 WHERE   m.name_2 = 'Ultimo') AND min_lat < (SELECT  ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
															      FROM    four_regions as m
																  WHERE   m.name_2 = 'Ultimo') AND max_long > (SELECT  ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																												    FROM    four_regions as m
																													WHERE   m.name_2 = 'Ultimo') AND min_long < (SELECT  ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																																									  FROM    four_regions as m
																																									  WHERE   m.name_2 = 'Ultimo')


	


-- Custom Polygon Clipping

Source: https://clydedacruz.github.io/openstreetmap-wkt-playground/#


POLYGON_1 = 'POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'


POLYGON_2 = 'POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))'

POLYGON_3 = 'POLYGON((11.303901672363283 46.50500922967828,11.362953186035158 46.51635073507512,11.402778625488281 46.48586507271446,11.282615661621096 46.46245750599604,11.285362243652346 46.48728338953961,11.38114929199219 46.49650154751427,11.303901672363283 46.50500922967828))'

SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*]*0.02,',rasdaman_op.geo2grid_coords('POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array 	


SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],',rasdaman_op.geo2grid_coords('POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))
'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array     


SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],',rasdaman_op.geo2grid_coords('POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))
'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array     
FROM    region_bavaria as m


SELECT rasdaman_op.geo2grid_coords('POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))')

SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],'
	,rasdaman_op.geo2grid_coords('POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'
	),') from Bavaria_Temperature_MODIS_1km AS c')) 

	
SELECT rasdaman_op.geo2grid_final('POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'
	,rasdaman_op.get_min_longitude('Bavaria_Temperature_MODIS_1km')
	,rasdaman_op.get_max_latitude('Bavaria_Temperature_MODIS_1km')
	,rasdaman_op.get_res_lon('Bavaria_Temperature_MODIS_1km'),
	rasdaman_op.get_res_lat('Bavaria_Temperature_MODIS_1km'))




SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],'
	,rasdaman_op.geo2grid_final('POLYGON((10.557861328125 50.73645513701064,10.557861328125 49.36806633482158,9.459228515625002 50.583236614805884,9.986572265625 49.32512199104002,8.052978515625 49.468124067331644,9.810791015625002 49.08106236432073,8.624267578125 48.47292127248784,9.854736328125 48.87916714896022,9.305419921875 47.62097541515848,10.052490234375 48.85025819972151,10.843505859375002 47.79839667295525,10.316162109374998 48.77791275550183,11.370849609375 48.71996122264625,10.579833984375002 48.951366470947704,13.128662109375002 48.951366470947704,10.755615234375 49.16733860629108,12.073974609375 49.73868163928003,10.777587890625 49.425267160837166,10.557861328125 50.73645513701064))'
	,rasdaman_op.get_min_longitude('Bavaria_Temperature_MODIS_1km')
	,rasdaman_op.get_max_latitude('Bavaria_Temperature_MODIS_1km')
	,rasdaman_op.get_res_lon('Bavaria_Temperature_MODIS_1km'),
	rasdaman_op.get_res_lat('Bavaria_Temperature_MODIS_1km')
	),') from Bavaria_Temperature_MODIS_1km AS c'))   



-- Temporal Clipping

SELECT rasdaman_op.query2array('select m[49:50, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as m') AS filtered_array

SELECT m.gid as gid,
rasdaman_op.query2array('select m[49:50, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as m') AS filtered_array
FROM region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- Spatial Clipping

SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip(c[100, 0:* , 0:*],',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),') from Bavaria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS regions,
rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C,
rasdaman_op.query2numeric(CONCAT('select max_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS max_temp_°C,
rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp_°C       
FROM    region_bavaria as m
WHERE   m.name_2 in ('Deggendorf',
	           'Mühldorf am Inn',
	           'Passau',
	           'Regen',
	           'Kelheim',
	           'Erding');


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'München';

SELECT  m.name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Bolzano';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'München';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Stockholm';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Umeå' LIMIT 1;

SELECT  m.name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Ultimo';


SELECT  name_1, name_2, name_3, 
	    rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762)
FROM    region_south_tyrol as m
WHERE   m.name_2 = 'Bolzano';


-- ##########################
-- ### TO INSTALL PLPYTHON ###
-- ##########################


sudo -i
[sudo] password for arkaghosh: 
JAVA_HOME: command not found
root@lat7410g:~# python3.8 -m  pip install rasterio folium
Collecting rasterio
  Downloading rasterio-1.3.11-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (21.8 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 21.8/21.8 MB 4.6 MB/s eta 0:00:00
Collecting folium
  Downloading folium-0.18.0-py2.py3-none-any.whl (108 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 108.9/108.9 kB 4.4 MB/s eta 0:00:00

-- ###########################################
-- ### LookUp Table Creation In petacopedb ###
-- ###########################################

-- 1. Selected Tables from petascopedb

SELECT * FROM public.axis_extent

SELECT * FROM public.geo_axis

SELECT * FROM public.index_axis

SELECT * FROM public.coverage

SELECT * FROM public.envelope

SELECT * FROM public.envelope_by_axis

SELECT * FROM public.wgs84_bounding_box
	

-- 2. lookup_temp (to get extent as double)
CREATE OR REPLACE VIEW lookup_temp_X AS
	SELECT coverage.id, coverage.coverage_id, wgs84_bounding_box.max_lat, wgs84_bounding_box.min_lat, wgs84_bounding_box.max_long, wgs84_bounding_box.min_long 	
	FROM public.coverage
	JOIN public.envelope ON coverage.envelope_id = envelope.envelope_id
	JOIN public.envelope_by_axis ON  envelope.envelope_by_axis_id = envelope_by_axis.envelope_by_axis_id
	JOIN public.wgs84_bounding_box ON envelope_by_axis.wgs84_bounding_box_id = wgs84_bounding_box.wgs84_bounding_box_id
		

-- 3. lookup_peta build from selected tables joined lookup_temp.
	
CREATE OR REPLACE VIEW lookup_peta_X AS	
	SELECT coverage.id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.lower_bound, axis_extent.grid_lower_bound, axis_extent.upper_bound, axis_extent.grid_upper_bound,lookup_temp_X.max_lat, lookup_temp_X.min_lat, lookup_temp_X.max_long, lookup_temp_X.min_long, geo_axis.resolution
	FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis, lookup_temp_X
	WHERE coverage.envelope_id = envelope.envelope_id 
	AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
	AND axis_extent.upper_bound = geo_axis.upper_bound
	AND coverage.id = lookup_temp_X.id

    -- OR

CREATE OR REPLACE VIEW lookup_peta_X AS	
    SELECT coverage.id, geo_axis.general_grid_id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.axis_type, axis_extent.uom_label AS unit, axis_extent.lower_bound, axis_extent.grid_lower_bound, axis_extent.upper_bound, axis_extent.grid_upper_bound, geo_axis.resolution
    FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis
    WHERE coverage.envelope_id = envelope.envelope_id 
    AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
    AND axis_extent.upper_bound = geo_axis.upper_bound

SELECT * FROM lookup_peta_X -- Lookup Table in petascopedb

-- 4. Switch to VectorDB and import lookup_peta_X as lookup_main_X using dblink

CREATE OR REPLACE VIEW lookup_main_X1 AS		
SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT id, coverage_id, axis_label, lower_bound, upper_bound, grid_lower_bound, grid_upper_bound, resolution, min_long, max_long, min_lat, max_lat FROM public.lookup_peta_x')
AS remote_table(raster_id text, raster_name text, axis_label text, domain_lower_bound text, domain_upper_bound date, grid_lower_bound date, grid_upper_bound integer, resolution float, min_long float, max_long float, min_lat float, max_lat float);



-- 5. Build sample_lookup_X

CREATE OR REPLACE VIEW sample_lookup_X1 AS
SELECT 
    raster_id,
    raster_name,
    MAX(CASE WHEN axis_label = 'Long' THEN min_long END) AS min_lon,
    MAX(CASE WHEN axis_label = 'Long' THEN max_long END) AS max_lon,
	MAX(CASE WHEN axis_label = 'Long' THEN grid_lower_bound END) AS min_lon_grid,
    MAX(CASE WHEN axis_label = 'Long' THEN grid_upper_bound END) AS max_lon_grid,
	MAX(CASE WHEN axis_label = 'Long' THEN resolution END) AS res_lon,
    MAX(CASE WHEN axis_label = 'Lat' THEN min_lat END) AS min_lat,
    MAX(CASE WHEN axis_label = 'Lat' THEN max_lat END) AS max_lat,
	MAX(CASE WHEN axis_label = 'Lat' THEN grid_lower_bound END) AS min_lat_grid,
    MAX(CASE WHEN axis_label = 'Lat' THEN grid_upper_bound END) AS max_lat_grid,
	MAX(CASE WHEN axis_label = 'Lat' THEN resolution END) AS res_lat,
	MAX(CASE WHEN axis_label = 'ansi' THEN domain_lower_bound date END) AS start_time,
    MAX(CASE WHEN axis_label = 'ansi' THEN domain_upper_bound date END) AS end_time,
	MAX(CASE WHEN axis_label = 'ansi' THEN grid_lower_bound END) AS start_time_grid,
    MAX(CASE WHEN axis_label = 'ansi' THEN grid_upper_bound END) AS end_time_grid,
	MAX(CASE WHEN axis_label = 'ansi' THEN resolution END) AS res_time
FROM lookup_main_X1
GROUP BY raster_id, raster_name;


select * from sample_lookup_X1 -- Build mappings with this table
	




	
-- In VectorDB using`dblink`

select nspname as schema
from pg_extension e
join pg_namespace n on n.oid = e.extnamespace
where extname = 'dblink'

SELECT pg_namespace.nspname, pg_proc.proname 
FROM pg_proc, pg_namespace 
WHERE pg_proc.pronamespace=pg_namespace.oid 
AND pg_proc.proname LIKE '%dblink%';


SELECT *
    FROM dblink('host=localhost dbname=Baveria user=postgres password=bolbona options=-csearch_path=','select gid, country from public.baveria_districts')
AS remote_table(gid int, country text);

SELECT dblink_connect('dbname=petascopedb options=-csearch_path=');

SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=postgres password=bolbona options=-csearch_path=','select coverage_id from public.coverage')
AS remote_table(coverage_id text);

SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=','select coverage_id from public.coverage')
AS remote_table(coverage_id text);


SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT coverage.coverage_id, wgs84_bounding_box.max_lat, wgs84_bounding_box.min_lat, wgs84_bounding_box.max_long, wgs84_bounding_box.min_long 	
		FROM public.coverage
		JOIN public.envelope_by_axis ON  envelope.envelope_by_axis_id = envelope_by_axis.envelope_by_axis_id
		JOIN public.wgs84_bounding_box ON envelope_by_axis.wgs84_bounding_box_id = wgs84_bounding_box.wgs84_bounding_box_id ')
AS remote_table(coverage_id text, max_lat float, min_lat float, max_long float, min_long float);


-- SQL TRIGGER AND LOOKUP Table


CREATE OR REPLACE FUNCTION update_lookup_table()
  RETURNS TRIGGER 
  LANGUAGE PLPGSQL
  AS
$$
BEGIN
	CREATE OR REPLACE VIEW LookUp AS
	SELECT coverage.id, geo_axis.general_grid_id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.axis_type, axis_extent.uom_label AS unit, axis_extent.lower_bound, axis_extent.grid_lower_bound,
		    axis_extent.upper_bound, axis_extent.grid_upper_bound, geo_axis.resolution
	FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis
	WHERE coverage.envelope_id = envelope.envelope_id 
	AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
	AND axis_extent.upper_bound = geo_axis.upper_bound;
 
    RETURN LookUp;	
END;
$$

CREATE TRIGGER update_lookup
AFTER UPDATE ON coverage
EXECUTE PROCEDURE update_lookup_table();



-- FUNCTION: public.update_lookup_table()

-- DROP FUNCTION IF EXISTS public.update_lookup_table();

CREATE OR REPLACE FUNCTION public.update_lookup_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
	CREATE OR REPLACE VIEW lookup_peta AS
SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT id, coverage_id, axis_label, max_lat, min_lat, max_long, min_long, resolution, lower_bound, upper_bound, grid_lower_bound, grid_upper_bound FROM public.lookup_peta')
		AS remote_table(id int, coverage_id text, axis_label text, max_lat float, min_lat float, max_long float, min_long float, resolution float, lower_bound text, upper_bound text, grid_lower_bound int, grid_upper_bound int); 
    
	RETURN lookup_peta;	
END;
$BODY$;

ALTER FUNCTION public.update_lookup_table()
    OWNER TO postgres;


-- FUNCTION: public.update_lookup()

-- DROP FUNCTION IF EXISTS public.update_lookup();

CREATE OR REPLACE FUNCTION public.update_lookup()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
	CREATE OR REPLACE VIEW lookup_main AS
SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT id, coverage_id, axis_label, max_lat, min_lat, max_long, min_long, resolution, lower_bound, upper_bound, grid_lower_bound, grid_upper_bound FROM public.lookup_peta')
		AS remote_table(id int, coverage_id text, axis_label text, max_lat float, min_lat float, max_long float, min_long float, resolution float, lower_bound text, upper_bound text, grid_lower_bound int, grid_upper_bound int); 
    
	RETURN lookup_main;	
END;
$BODY$;

ALTER FUNCTION public.update_lookup()
    OWNER TO postgres;


-- FUNCTION: public.update_lookup()

-- DROP FUNCTION IF EXISTS public.update_lookup();

CREATE OR REPLACE FUNCTION public.update_lookup()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
	CREATE OR REPLACE VIEW lookup_main AS
SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT id, coverage_id, axis_label, max_lat, min_lat, max_long, min_long, resolution, lower_bound, upper_bound, grid_lower_bound, grid_upper_bound FROM public.lookup_peta')
		AS remote_table(id int, coverage_id text, axis_label text, max_lat float, min_lat float, max_long float, min_long float, resolution float, lower_bound text, upper_bound text, grid_lower_bound int, grid_upper_bound int); 
    
	RETURN lookup_main;	
END;
$BODY$;

ALTER FUNCTION public.update_lookup()
    OWNER TO postgres;




-- MaxLon, MinLat inclusoin in the geo2grid python procedure

SELECT min_long as xmin, max_lat as ymax  FROM lookup_02 WHERE coverage_id = 'Baveria_Temperature_MODIS_1km'

SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';



SELECT  8.979166665862266 AS minlon, 50.56666666213664 AS maxlat     


SELECT rasdaman_op.query2array('select rasdb[49, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as rasdb')



SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';


SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),') from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';



SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)) AS Geom   
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- FDW

SELECT dblink_connect('host=localhost user=postgres password=bolbona dbname=VectorDB');

CREATE FOREIGN DATA WRAPPER postgres VALIDATOR postgresql_fdw_validator;

CREATE SERVER petascope_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'petascopedb');

CREATE USER MAPPING FOR postgres SERVER petascope_server OPTIONS (schema_name 'public', user 'petauser', password 'bolbona');

GRANT USAGE ON FOREIGN SERVER petascope_server TO postgres;

SELECT dblink_connect('petascopedb');

SELECT * FROM dblink('petascopedb','select envelope_id from envelope');

-- Time Translation (Days)
-- 2022-08-24T00:00:00+00:00 rquivalent 145 for Sweden

SELECT start_time, TO_TIMESTAMP(
    start_time,
    '%Y-%m-%dT%H:%M:%E*SZ'
)
FROM sample_lookup_X1
WHERE raster_name = 'Surface_Temperature_Sweden';


SELECT start_time_grid + EXTRACT(DAY FROM (TIMESTAMP '2022-05-06T00:00:00+00:00' -  start_time::TIMESTAMP)) 
FROM sample_lookup_X1
WHERE raster_name = 'Surface_Temperature_Sweden'




CREATE OR REPLACE FUNCTION rasdaman_op.timestamp2grid(input_time text, input_raster text)
RETURNS INTEGER AS $$
DECLARE
    example_date_grid_val INTEGER;
BEGIN
    SELECT start_time_grid + EXTRACT(DAY FROM (input_time::TIMESTAMP - start_time::TIMESTAMP))INTO example_date_grid_val
    FROM sample_lookup_X1
    WHERE start_time::TIMESTAMP <= input_time::TIMESTAMP AND end_time::TIMESTAMP >= input_time::TIMESTAMP AND raster_name = input_raster;
    
    RETURN example_date_grid_val;
END;

$$ LANGUAGE plpgsql;



SELECT rasdaman_op.timestamp2grid('2022-08-23T00:00:00+00:00', 'Surface_Temperature_Sweden') 




SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[145, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[',rasdaman_op.timestamp2grid('2022-08-24T00:00:00+00:00','Surface_Temperature_Sweden'),',0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';



CREATE OR REPLACE FUNCTION rasdaman_op.timestamp2grid_X(input_time text, input_raster_id integer)
RETURNS INTEGER AS $$
DECLARE
    example_date_grid_val INTEGER;
BEGIN
    SELECT start_time_grid + EXTRACT(DAY FROM (input_time::TIMESTAMP - start_time::TIMESTAMP))INTO example_date_grid_val
    FROM sample_lookup_X1
    WHERE start_time::TIMESTAMP <= input_time::TIMESTAMP AND end_time::TIMESTAMP >= input_time::TIMESTAMP AND raster_id::integer = input_raster_id;
    
    RETURN example_date_grid_val;
END;

$$ LANGUAGE plpgsql;



SELECT rasdaman_op.timestamp2grid_X('2022-08-23T00:00:00+00:00', 407) 


-- Time Translation (Months)
-- 2022-08-24T00:00:00+00:00 rquivalent 145 for Sweden


-- FUNCTION: rasdaman_op.get_geom(geometry)

-- DROP FUNCTION IF EXISTS rasdaman_op.get_geom(geometry);

CREATE OR REPLACE FUNCTION rasdaman_op.get_geom(
	geometry_wkt geometry)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    out_geom_wkt TEXT;
BEGIN
	SELECT 
	    CASE 
	        WHEN ST_NumGeometries(geometry_wkt) = 1 THEN ST_AsText(ST_GeometryN(geometry_wkt, 1))
	        ELSE ST_AsText(geometry_wkt)
	    END AS geometry_wkt INTO out_geom_wkt;

	RETURN out_geom_wkt;
END;

$BODY$;

ALTER FUNCTION rasdaman_op.get_geom(geometry)
    OWNER TO postgres;



--PLPYTHON Functions

-- FUNCTION: rasdaman_op.geo2grid_coords(text)

-- DROP FUNCTION IF EXISTS rasdaman_op.geo2grid_coords(text);

CREATE OR REPLACE FUNCTION rasdaman_op.geo2grid_coords(
	"geoPOLY" text,
	OUT "gridPOLY" text)
    RETURNS text
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
import numpy as np
import re
import gdal
from affine import Affine
from shapely.geometry import Polygon
from shapely import wkt

xmin = 10.38333333240314  
ymax = 47.099999995780536 
pixel_size = 0.008333333332586793

def grid2WKT_polygon(y_grid, x_grid):
    coordinates = list(zip(y_grid, x_grid))
    polygon = "POLYGON((" + ", ".join(f"{x} {y}" for x, y in coordinates) + "))"
    return polygon

def geo2grid(lons, lats, xmin, ymax, pixel_size, xskew = 0.0, yskew = 0.0):
    aff_gdal = Affine.from_gdal(xmin, pixel_size, xskew, ymax, 0.0, -pixel_size)
    lons = np.array(lons)
    lats = np.array(lats)
    xs, ys = ~aff_gdal*(lons, lats)
    xs = np.int64(xs)
    ys = np.int64(ys)
    return xs, ys 

def add_closing_coordinates(d):
    i = re.search(r"\d", d).start()
    j = re.search(r'(\d)[^\d]*$', d).start() + 1
    c = d.index(',')    
    return d[:j] + ", " + d[i:c] + d[j:]

def processPOLYGON(inputPOLYGON, regionID = None):
    if inputPOLYGON.area < pixel_size:
	    pass
    elif len(inputPOLYGON.interiors) == 0:
        coords = np.dstack(inputPOLYGON.boundary.xy).tolist()[0][:-1]
        expected_list_of_coordinates_for_received_code = [{"long": x, "lat": y} for x, y in coords]
        lat_arr = []
        long_arr = []
        for i in range(len(expected_list_of_coordinates_for_received_code)):
            long_arr = np.append(long_arr, expected_list_of_coordinates_for_received_code[i]['long'])
            lat_arr = np.append(lat_arr, expected_list_of_coordinates_for_received_code[i]['lat'])

        long_list = long_arr.tolist()
        lat_list = lat_arr.tolist()

        x_grid, y_grid = geo2grid(long_list, lat_list, xmin, ymax, pixel_size)
        gridPOLYGON_yx = grid2WKT_polygon(y_grid, x_grid)

        return gridPOLYGON_yx
    else:
        print(f"{regionID}: Polygon Ring Detected")
        mainPOLYGON = Polygon(inputPOLYGON.exterior)  
        gridPOLYGON_yx = processPOLYGON(mainPOLYGON)

        return gridPOLYGON_yx

           
def geoPOLYGON_to_gridPOLYGON_03(inputREGION, regionID = None):
    polygons_array1 = []
    polygons_array2 = []
    i = 0
    r = 0
    inputREGION = wkt.loads(inputREGION)
    if inputREGION.geom_type == 'Polygon':
        return processPOLYGON(inputREGION, regionID)
    
    elif len(list(inputREGION.geoms[0].interiors)) > 0:         
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array1.append(gridPOLYGON)
            r = r +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array1]
        return shapely.geometry.MultiPolygon(gridMULTI)

    else:                                                  
        print(f"{regionID}: MultiPolygon is processing")
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array2.append(gridPOLYGON)
            i = i +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array2]
        return shapely.geometry.MultiPolygon(gridMULTI)

gridPOLY = geoPOLYGON_to_gridPOLYGON_03(geoPOLY)
return gridPOLY
$BODY$;

ALTER FUNCTION rasdaman_op.geo2grid_coords(text)
    OWNER TO postgres;


-- FUNCTION: rasdaman_op.geo2grid_final(text, double precision, double precision, double precision, double precision)

-- DROP FUNCTION IF EXISTS rasdaman_op.geo2grid_final(text, double precision, double precision, double precision, double precision);

CREATE OR REPLACE FUNCTION rasdaman_op.geo2grid_final(
	"geoPOLY" text,
	min_lon double precision,
	max_lat double precision,
	resolution_lon double precision,
	resolution_lat double precision,
	OUT "gridPOLY" text)
    RETURNS text
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
import numpy as np
import re
import gdal
from affine import Affine
from shapely.geometry import Polygon
from shapely.ops import unary_union
from shapely import wkt

def grid2WKT_polygon(y_grid, x_grid):
    coordinates = list(zip(y_grid, x_grid))
    polygon = "POLYGON((" + ", ".join(f"{x} {y}" for x, y in coordinates) + "))"
    return polygon

def geo2grid(lons, lats, xmin, ymax, x_scale, y_scale, xskew = 0.0, yskew = 0.0):
    aff_gdal = Affine.from_gdal(xmin, x_scale, xskew, ymax, 0.0, -y_scale)
    lons = np.array(lons)
    lats = np.array(lats)
    xs, ys = ~aff_gdal*(lons, lats)
    xs = np.int64(xs)
    ys = np.int64(ys)
    return xs, ys 

def add_closing_coordinates(d):
    i = re.search(r"\d", d).start()
    j = re.search(r'(\d)[^\d]*$', d).start() + 1
    c = d.index(',')    
    return d[:j] + ", " + d[i:c] + d[j:]

def processPOLYGON(inputPOLYGON):
    if inputPOLYGON.area < x_scale:
	    pass
    elif len(inputPOLYGON.interiors) == 0:
        coords = np.dstack(inputPOLYGON.boundary.xy).tolist()[0][:-1]
        expected_list_of_coordinates_for_received_code = [{"long": x, "lat": y} for x, y in coords]
        lat_arr = []
        long_arr = []
        for i in range(len(expected_list_of_coordinates_for_received_code)):
            long_arr = np.append(long_arr, expected_list_of_coordinates_for_received_code[i]['long'])
            lat_arr = np.append(lat_arr, expected_list_of_coordinates_for_received_code[i]['lat'])

        long_list = long_arr.tolist()
        lat_list = lat_arr.tolist()

        x_grid, y_grid = geo2grid(long_list, lat_list, xmin, ymax, x_scale, y_scale)
        gridPOLYGON_yx = grid2WKT_polygon(y_grid, x_grid)

        return gridPOLYGON_yx
    else:
        mainPOLYGON = Polygon(inputPOLYGON.exterior)  
        gridPOLYGON_yx = processPOLYGON(mainPOLYGON)

        return gridPOLYGON_yx

def geoPOLYGON_to_gridPOLYGON_03(inputREGION, min_lon, max_lat, resolution_lon, resolution_lat):
    polygons_array1 = []
    polygons_array2 = []
    i = 0
    r = 0
    global xmin
    xmin = min_lon
    global ymax
    ymax= max_lat
    global x_scale
    x_scale = resolution_lon
    global y_scale
    y_scale = resolution_lat
	
    inputREGION = wkt.loads(inputREGION)
    if inputREGION.geom_type == 'Polygon':
        return processPOLYGON(inputREGION)
    
    elif len(list(inputREGION.geoms[0].interiors)) > 0:         
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array1.append(gridPOLYGON)
            r = r +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array1]
        return shapely.geometry.MultiPolygon(gridMULTI)

    else:                                                  
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array2.append(gridPOLYGON)
            i = i +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array2]
        return shapely.geometry.MultiPolygon(unary_union(gridMULTI))	
	
gridPOLY = geoPOLYGON_to_gridPOLYGON_03(geoPOLY, min_lon, max_lat, resolution_lon, resolution_lat)
return gridPOLY
	
           
$BODY$;

ALTER FUNCTION rasdaman_op.geo2grid_final(text, double precision, double precision, double precision, double precision)
    OWNER TO postgres;

	
           
-- FUNCTION: rasdaman_op.query2array(text)

CREATE OR REPLACE FUNCTION rasdaman_op.query2array(
	query text,
	OUT data_array double precision[])
    RETURNS double precision[]
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
from rasdapy.db_connector import DBConnector
from rasdapy.query_executor import QueryExecutor

def query2array(query):
    result = query_executor.execute_read(query) 
    numpy_array = result.to_array()
    return numpy_array.tolist()  
	
db_connector = DBConnector("localhost", 7001, "rasadmin", "rasadmin")
query_executor = QueryExecutor(db_connector)
db_connector.open()

try:
   data_array= query2array(query)
   return data_array
finally:
   db_connector.close()
$BODY$;

ALTER FUNCTION rasdaman_op.query2array(text)
    OWNER TO postgres;


-- FUNCTION: rasdaman_op.query2numeric(text)

-- DROP FUNCTION IF EXISTS rasdaman_op.query2numeric(text);

CREATE OR REPLACE FUNCTION rasdaman_op.query2numeric(
	query text,
	OUT double precision)
    RETURNS double precision
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
from rasdapy.db_connector import DBConnector
from rasdapy.query_executor import QueryExecutor

def query2result(query):
   output_val = query_executor.execute_read(query)
   output_val = float("{}".format(output_val))
   return output_val
	
db_connector = DBConnector("localhost", 7001, "rasadmin", "rasadmin")
query_executor = QueryExecutor(db_connector)
db_connector.open()

try:
   return float("{:.3f}".format(query2result(query)))
finally:
   db_connector.close()
$BODY$;

ALTER FUNCTION rasdaman_op.query2numeric(text)
    OWNER TO postgres;

-- FUNCTION: rasdaman_op.query2geotiff02(text, text, text, double precision)

-- DROP FUNCTION IF EXISTS rasdaman_op.query2geotiff02(text, text, text, double precision);

CREATE OR REPLACE FUNCTION rasdaman_op.query2geotiff02(
	query text,
	geomm text,
	filename text,
	fill_val double precision,
	OUT folium text)
    RETURNS text
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
from rasdapy.db_connector import DBConnector
from rasdapy.query_executor import QueryExecutor
from shapely import Point, Polygon, bounds, wkt
import numpy as np
import os
import gdal
from osgeo import osr
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
import rasterio
from rasterio.plot import show, reshape_as_image, reshape_as_raster, reshape_as_image
import folium
from folium.raster_layers import ImageOverlay

def getGeoTransform(extent, nlines, ncols):
    resx = (extent[2] - extent[0]) / ncols
    resy = (extent[3] - extent[1]) / nlines
    return [extent[0], resx, 0, extent[3] , 0, -resy]
	
def query2folium(query, region, filename, fill_val):
    result = query_executor.execute_read(query) 
    numpy_array = result.to_array()
    if fill_val is not None:
        numpy_array = numpy_array.astype('float')
        numpy_array[numpy_array == fill_val] = 'nan'

    driver = gdal.GetDriverByName('GTiff')  
    nrows = numpy_array.shape[0]
    ncols = numpy_array.shape[1]
    nbands = len(numpy_array.shape)
    data_type = gdal.GDT_Float32
    grid_data = driver.Create('grid_data', ncols, nrows, 1, data_type)
    grid_data.GetRasterBand(1).WriteArray(numpy_array)
    srs = osr.SpatialReference()
    srs.ImportFromProj4('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
    grid_data.SetProjection(srs.ExportToWkt())
    region = wkt.loads(region)
    if region.geom_type == 'Polygon':    
        extent = [11.5028, 48.1255, 11.5308, 48.1438] # bounds(region).tolist()
        grid_data.SetGeoTransform(getGeoTransform(extent, nrows, ncols))	
    
    file_name = str(filename)+'.tif'
    driver.CreateCopy(file_name, grid_data, 0)  
    driver = None
    grid_data = None          
    os.remove('grid_data')
    elevRaster = rasterio.open(file_name)
    elevArray = elevRaster.read(1)
    boundList = [x for x in elevRaster.bounds]
    norm = Normalize(vmin=np.nanmin(elevArray), vmax=np.nanmax(elevArray))
    cmap = plt.cm.get_cmap('jet')
    def colormap_function(x):
        rgba = cmap(norm(x))
        return (rgba[0], rgba[1], rgba[2], rgba[3])

    rasLon = (boundList[3] + boundList[1])/2
    rasLat = (boundList[2] + boundList[0])/2
    mapCenter = [rasLon, rasLat]

    mf = folium.Map(location=mapCenter, zoom_start=13)
    folium.raster_layers.ImageOverlay(
        image=elevArray,
        bounds=[[boundList[1], boundList[0]], [boundList[3], boundList[2]]],
        opacity=0.52,
        colormap=colormap_function,  
		interactive=True,
        cross_origin=False,
    ).add_to(mf)
    
    return mf

db_connector = DBConnector("localhost", 7001, "rasadmin", "rasadmin")
query_executor = QueryExecutor(db_connector)
db_connector.open()

try:
   folium= query2folium(query, geomm, None, None)
   return folium
finally:
   db_connector.close()	
$BODY$;

ALTER FUNCTION rasdaman_op.query2geotiff02(text, text, text, double precision)
    OWNER TO postgres;



-- EXPERIMENTING

SELECT  name_2, geom
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'; --Göteborg Umeå Leksand

SELECT name_1,name_2, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Göteborg','Umeå') ;

SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797)     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'; --Göteborg Umeå Leksand


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select max_cells(clip((c[145, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg' LIMIT 1;

SELECT  name_1, name_2,
	    rasdaman_op.geo2grid_final(ST_AsText(geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762) as geom
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg';


SELECT  name_1, name_2,
	    rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762) as geom
FROM    region_south_tyrol as m
WHERE   m.name_2 = 'Göteborg';


SELECT name_1,name_2, length(ST_AsText(geom)), ST_AsText(geom) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Göteborg','Umeå', 'Linköping') ;



SELECT name_1,name_2, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Linköping','Göteborg','Umeå') ;



-- ###################################################################################################################################################################################################################

SELECT  name_2, geom
FROM    region_bavaria as m
WHERE   m.name_2 = 'Bayreuth'; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Bayreuth'; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797)     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2, geom AS region
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


-- ###################################################################################################################################################################################################################

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Bolzano'; -- Lagundo Racines Senales Bolzano

SELECT name_1,name_2, name_3, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_south_tyrol   -- Multipolygons to polygons
WHERE name_3 ='Bolzano';

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Senales'; -- Lagundo Racines Senales

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Lagundo'; -- Lagundo Racines Senales

SELECT  name_1, name_2, name_3, 
	    rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762)
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Lagundo' LIMIT 1;


SELECT  name_1, name_2, name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Senales' LIMIT 1;




SELECT rasdaman_op.get_max_lat('Surface_Temperature_Sweden')

SELECT rasdaman_op.get_res_lon('Surface_Temperature_Sweden')

SELECT rasdaman_op.get_res_lat('Surface_Temperature_Sweden')



SELECT rasdaman_op.get_min_longitude('Surface_Temperature_Sweden')
	
SELECT rasdaman_op.get_max_latitude('Surface_Temperature_Sweden')

	
SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[145, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),
	')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';





select * from sample_lookup_X1 















-- Import maxlat, minlon into geo2grid from sample_lookup_x1
import plpy

def retrieve_column_as_text(table_name, column_name):
plan = plpy.prepare(f"SELECT {column_name}::TEXT FROM {table_name}", [])
rv = plpy.execute(plan)
column_data = [r[column_name] for r in rv]
return column_data

# Example usage
result = retrieve_column_as_text('your_table_name', 'your_column_name')
plpy.notice(result) 




SELECT name_1,name_2, ST_AsText(geom) FROM public.region_bavaria   -- Multipolygons to polygons
WHERE name_2 in ('München','München (Kreisfreie Stadt)') ;

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[145, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[273, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_max_latitude('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_res_lon('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_res_lat('Bavaria_Temperature_MODIS_1km')),')) from Bavaria_Temperature_MODIS_1km AS c')) AS val     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Cham' 


SELECT  m.name_2 AS region,
rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden'))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Cham'




SELECT name_1,name_2, length(ST_AsText(geom)), ST_AsText(ST_GeometryN(geom, 1)) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Göteborg','Umeå', 'Linköping', 'Stockholm') ;



SELECT name_1,name_2, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Linköping','Göteborg','Umeå','Stockholm') ;



SELECT  name_1, name_2, name_3, 
	    rasdaman_op.geo2grid_final(ST_AsText(geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762) as geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'bolzano';



SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip(c[145, 0:* , 0:*],',rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Söderköping'

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[273, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_max_latitude('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_res_lon('Bavaria_Temperature_MODIS_1km'),rasdaman_op.get_res_lat('Bavaria_Temperature_MODIS_1km')),')) from Bavaria_Temperature_MODIS_1km AS c')) AS val     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Cham' 


SELECT  m.name_2 AS region,
rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden'))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Cham'



-- Sample input
WITH input_data AS (
    SELECT 'MULTIPOLYGON(((30 10, 40 40, 20 40, 10 20, 30 10)))'::geometry AS geom
)

-- Convert MULTIPOLYGON to POLYGON
SELECT ST_AsText(ST_GeometryN(geom, 1)) AS polygon_geometry
FROM input_data;



-- Sample input
WITH input_data AS (
    SELECT 'MULTIPOLYGON(((30 10, 40 40, 20 40, 10 20, 30 10)))'::geometry AS geom
)

-- Convert MULTIPOLYGON to POLYGON if it contains only one polygon, else return as is
SELECT 
    CASE 
        WHEN ST_NumGeometries(geom) = 1 THEN ST_AsText(ST_GeometryN(geom, 1))
        ELSE ST_AsText(geom)
    END AS geometry
FROM input_data;

    


SELECT name_2, length(ST_AsText(geom)),ST_NumGeometries(geom), geom FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Göteborg','Umeå', 'Linköping', 'Stockholm') ;



SELECT name_3, length(ST_AsText(geom)),ST_NumGeometries(geom), geom FROM region_south_tyrol   -- Multipolygons to polygons



select * FROM sample_regions_of_interest


SELECT name_2,ST_NumGeometries(geom),ST_AsText(geom), geom FROM sample_regions_of_interest


-- Convert MULTIPOLYGON to POLYGON if it contains only one polygon, else return as is

SELECT region_id, name_2 AS region_name, ST_NumGeometries(geom) AS num_of_polygons,
       CASE
           WHEN ST_NumGeometries(geom) = 1 THEN ST_AsText(ST_GeometryN(geom, 1))
           ELSE ST_AsText(geom)
        END AS region_geometry_wkt
FROM sample_regions_of_interest


SELECT region_id, name_2 AS region_name, ST_AsText(ST_GeometryN(geom, 1))
	FROM sample_regions_of_interest





	



	
SELECT
    CASE 
        WHEN ST_NumGeometries(geom) = 1 THEN ST_AsText(ST_GeometryN(geom, 1))
        ELSE ST_AsText(geom)
    END AS geometry
FROM    region_south_tyrol 
WHERE   name_3 = 'Bolzano';







-- SELECT  m.name_3 AS region,
--         rasdaman_op.query2numeric(CONCAT('select avg_cells(clip(c[145, 0:* , 0:*],',rasdaman_op.geo2grid_final(ST_AsText(ST_GeometryN(geom, 1)),rasdaman_op.get_min_longitude('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_max_latitude('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_res_lon('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_res_lat('South_Tyrol_Temperature_MODIS_1km')),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS val     
-- FROM    region_south_tyrol as m
-- WHERE   m.name_3 = 'Brennero'

-- SELECT  m.name_3 AS region, ST_AsText(ST_GeometryN(geom, 1)), geom
-- FROM    region_south_tyrol as m
-- WHERE   m.name_3 = 'Ultimo'


	


	
SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[145, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip(c[145, 0:* , 0:*],',rasdaman_op.geo2grid_final(ST_AsText(ST_GeometryN(geom, 1)),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping'


SELECT  m.name_2 AS region, ST_AsText((ST_Dump(geom)).geom)
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping'


SELECT  name_3, rasdaman_op.get_geom(geom)
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Bolzano'



SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[145, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(rasdaman_op.get_geom(geom),rasdaman_op.get_min_longitude('Surface_Temperature_Sweden'),rasdaman_op.get_max_latitude('Surface_Temperature_Sweden'),rasdaman_op.get_res_lon('Surface_Temperature_Sweden'),rasdaman_op.get_res_lat('Surface_Temperature_Sweden')),')) from Surface_Temperature_Sweden AS c')) AS output_val     
FROM    region_sweden as m
WHERE   m.name_2 = 'Söderköping'



SELECT  m.name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[283, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(rasdaman_op.get_geom(geom),rasdaman_op.get_min_longitude('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_max_latitude('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_res_lon('South_Tyrol_Temperature_MODIS_1km'),rasdaman_op.get_res_lat('South_Tyrol_Temperature_MODIS_1km')),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS output_val     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Merano'








