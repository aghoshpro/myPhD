TODO

User Designer Developer

1. max_lot, min_lat, x_res, y_res from plpython (not mentioned in RasSparql and not in mappings)
2. automate the mappings for geometry based raster searching
3. DecTables 
4. Lookup Table needs to be more robust
5. 


-- Regions: Deggendorf .
-- Raster Baveria_Temperature_MODIS_1km --
-- xmin = 8.979166665862266  
-- ymax = 50.56666666213664 
-- pixel_size = 0.008333333332587


-- Regions: Linköping.
-- Raster Surface_Temperature_Sweden --
-- xmin = 10.958333332351629  
-- ymax = 69.06666666047931 
-- pixel_size = 0.008333333332586788


-- Regions: Ultimo. 
-- Raster South_Tyrol_Temperature_MODIS_1km --
-- xmin = 10.38333333240314  
-- ymax = 47.099999995780536 
-- pixel_size = 0.008333333332586793


-- Regions of Interest (ROI)


SELECT * FROM public.region_sweden
WHERE name_3 LIKE '%Ume%';

SELECT * FROM public.region_south_tyrol
WHERE name_3 LIKE '%Bolzano%';

CREATE OR REPLACE VIEW Four_Regions AS
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Deggendorf'
UNION
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'München'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Linköping'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Ultimo'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Stockholm'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Bolzano';



-- Fetch raster data name based on vector region name
SELECT  m.name_2 AS region,ST_XMax(ST_GeomFromText(geom))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- Xmin and min_long
SELECT  m.name_2 AS region, ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

-- Ymax and max_lat
SELECT  m.name_2 AS region, ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))) as max_lat_V
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

-- BBOX
SELECT  m.name_2 AS region, ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom))), ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT DISTINCT coverage_id as raster_name
FROM lookup_main
WHERE max_lat > (SELECT  ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
				 FROM    region_sweden as m
				 WHERE   m.name_2 = 'Linköping') AND min_lat < (SELECT  ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
															      FROM    region_sweden as m
																  WHERE   m.name_2 = 'Linköping') AND max_long > (SELECT  ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																												    FROM    region_sweden as m
																													WHERE   m.name_2 = 'Linköping') AND min_long < (SELECT  ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																																									  FROM    region_sweden as m
																																									  WHERE   m.name_2 = 'Linköping')

																																									  



	
-- Custom Table that hold all regions of three different raster

CREATE VIEW Four_Regions AS
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Deggendorf'
UNION
SELECT gid, name_2, country, geom FROM public.region_bavaria WHERE name_2 = 'Regen'
UNION
SELECT gid, name_2, name_0, geom FROM public.region_sweden WHERE name_2 = 'Linköping'
UNION
SELECT gid, name_3, country, geom FROM public.region_south_tyrol WHERE name_3 = 'Ultimo';


SELECT DISTINCT coverage_id as raster_name
FROM lookup_main
WHERE max_lat > (SELECT  ST_YMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
				 FROM    four_regions as m
				 WHERE   m.name_2 = 'Ultimo') AND min_lat < (SELECT  ST_YMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
															      FROM    four_regions as m
																  WHERE   m.name_2 = 'Ultimo') AND max_long > (SELECT  ST_XMax(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																												    FROM    four_regions as m
																													WHERE   m.name_2 = 'Ultimo') AND min_long < (SELECT  ST_XMin(ST_GeomFromText(ST_AsText((ST_Dump(m.geom)).geom)))
																																									  FROM    four_regions as m
																																									  WHERE   m.name_2 = 'Ultimo')


	


-- Custom Polygon Clipping

Source: https://clydedacruz.github.io/openstreetmap-wkt-playground/#


POLYGON_1 = 'POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'


POLYGON_2 = 'POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))'


SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*]*0.02,',rasdaman_op.geo2grid_coords('POLYGON((11.324157714843748 48.29050321714061,11.911926269531248 48.279537342260085,11.88995361328125 48.01932418480118,11.340637207031248 48.01564978668938,11.324157714843748 48.29050321714061))'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array 	


SELECT  rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],',rasdaman_op.geo2grid_coords('POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))
'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array     


SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip(c[246, 0:* , 0:*],',rasdaman_op.geo2grid_coords('POLYGON ((10.557861328125 50.73645513701064, 10.557861328125 49.36806633482158, 9.459228515625002 50.583236614805884, 9.986572265625 49.32512199104002, 8.052978515625 49.468124067331644, 9.810791015625002 49.08106236432073, 8.624267578125 48.47292127248784, 9.854736328125 48.87916714896022, 9.305419921875 47.62097541515848, 10.052490234375 48.85025819972151, 10.843505859375002 47.79839667295525, 10.316162109375 48.77791275550183, 11.370849609375 48.71996122264625, 10.579833984375002 48.951366470947704, 13.128662109375002 48.951366470947704, 10.755615234375 49.16733860629108, 12.073974609375 49.73868163928003, 10.777587890625 49.425267160837166, 10.557861328125 50.73645513701064))
'),') from Baveria_Temperature_MODIS_1km AS c')) AS filtered_array     
FROM    region_bavaria as m



-- Temporal Clipping

SELECT rasdaman_op.query2array('select m[49:50, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as m') AS filtered_array

SELECT m.gid as gid,
rasdaman_op.query2array('select m[49:50, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as m') AS filtered_array
FROM region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- Spatial Clipping

SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip(c[100, 0:* , 0:*],',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),') from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS regions,
rasdaman_op.query2numeric(CONCAT('select avg_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C,
rasdaman_op.query2numeric(CONCAT('select max_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS max_temp_°C,
rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02) - 273.15,',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(m.geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp_°C       
FROM    region_bavaria as m
WHERE   m.name_2 in ('Deggendorf',
	           'Mühldorf am Inn',
	           'Passau',
	           'Regen',
	           'Kelheim',
	           'Erding');


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'München';

SELECT  m.name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Bolzano';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'München';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Stockholm';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Umeå' LIMIT 1;

SELECT  m.name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Ultimo';


SELECT  name_1, name_2, name_3, 
	    rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762)
FROM    region_south_tyrol as m
WHERE   m.name_2 = 'Bolzano';






-- ###########################################
-- ### LookUp Table Creation In petacopedb ###
-- ###########################################

-- 1. Selected Tables from petascopedb

SELECT * FROM public.axis_extent

SELECT * FROM public.geo_axis

SELECT * FROM public.index_axis

SELECT * FROM public.coverage

SELECT * FROM public.envelope

SELECT * FROM public.envelope_by_axis

SELECT * FROM public.wgs84_bounding_box
	

-- 2. lookup_temp (optional)
CREATE OR REPLACE VIEW lookup_temp_X AS
	SELECT coverage.id, coverage.coverage_id, wgs84_bounding_box.max_lat, wgs84_bounding_box.min_lat, wgs84_bounding_box.max_long, wgs84_bounding_box.min_long 	
	FROM public.coverage
	JOIN public.envelope ON coverage.envelope_id = envelope.envelope_id
	JOIN public.envelope_by_axis ON  envelope.envelope_by_axis_id = envelope_by_axis.envelope_by_axis_id
	JOIN public.wgs84_bounding_box ON envelope_by_axis.wgs84_bounding_box_id = wgs84_bounding_box.wgs84_bounding_box_id
		

-- 3. lookup_peta build from selected tables joined lookup_temp.
	
CREATE OR REPLACE VIEW lookup_peta_X AS	
	SELECT coverage.id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.lower_bound, axis_extent.grid_lower_bound, axis_extent.upper_bound, axis_extent.grid_upper_bound,lookup_temp_X.max_lat, lookup_temp_X.min_lat, lookup_temp_X.max_long, lookup_temp_X.min_long, geo_axis.resolution
	FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis, lookup_temp_X
	WHERE coverage.envelope_id = envelope.envelope_id 
	AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
	AND axis_extent.upper_bound = geo_axis.upper_bound
	AND coverage.id = lookup_temp_X.id

    -- OR

CREATE OR REPLACE VIEW lookup_peta_X AS	
    SELECT coverage.id, geo_axis.general_grid_id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.axis_type, axis_extent.uom_label AS unit, axis_extent.lower_bound, axis_extent.grid_lower_bound, axis_extent.upper_bound, axis_extent.grid_upper_bound, geo_axis.resolution
    FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis
    WHERE coverage.envelope_id = envelope.envelope_id 
    AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
    AND axis_extent.upper_bound = geo_axis.upper_bound

SELECT * FROM lookup_peta_X -- Lookup Table in petascopedb

-- 4. Switch to VectorDB and import lookup_peta_X as lookup_main_X using dblink

CREATE OR REPLACE VIEW lookup_main_X AS		
SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT id, coverage_id, axis_label, lower_bound, upper_bound, resolution, grid_lower_bound, grid_upper_bound FROM public.lookup_peta_x')
AS remote_table(raster_id text, raster_name text, axis_label text, domain_lower_bound text, domain_upper_bound text, resolution float, grid_lower_bound integer, grid_upper_bound integer);


-- 5. Build sample_lookup_X

CREATE OR REPLACE VIEW sample_lookup_X AS
SELECT 
    raster_id,
    raster_name,
    MAX(CASE WHEN axis_label = 'Long' THEN domain_lower_bound END) AS min_lon,
    MAX(CASE WHEN axis_label = 'Long' THEN domain_upper_bound END) AS max_lon,
	MAX(CASE WHEN axis_label = 'Long' THEN grid_lower_bound END) AS min_lon_grid,
    MAX(CASE WHEN axis_label = 'Long' THEN grid_upper_bound END) AS max_lon_grid,
	MAX(CASE WHEN axis_label = 'Long' THEN resolution END) AS res_lon,
    MAX(CASE WHEN axis_label = 'Lat' THEN domain_lower_bound END) AS min_lat,
    MAX(CASE WHEN axis_label = 'Lat' THEN domain_upper_bound END) AS max_lat,
	MAX(CASE WHEN axis_label = 'Lat' THEN grid_lower_bound END) AS min_lat_grid,
    MAX(CASE WHEN axis_label = 'Lat' THEN grid_upper_bound END) AS max_lat_grid,
	MAX(CASE WHEN axis_label = 'Lat' THEN resolution END) AS res_lat,
	MAX(CASE WHEN axis_label = 'ansi' THEN domain_lower_bound END) AS start_time,
    MAX(CASE WHEN axis_label = 'ansi' THEN domain_upper_bound END) AS end_time,
	MAX(CASE WHEN axis_label = 'ansi' THEN grid_lower_bound END) AS start_time_grid,
    MAX(CASE WHEN axis_label = 'ansi' THEN grid_upper_bound END) AS end_time_grid,
	MAX(CASE WHEN axis_label = 'ansi' THEN resolution END) AS res_time
FROM lookup_main_X
GROUP BY raster_id, raster_name;


select * from sample_lookup_X -- Build mappings with this table
	




	
-- In VectorDB using`dblink`

select nspname as schema
from pg_extension e
join pg_namespace n on n.oid = e.extnamespace
where extname = 'dblink'

SELECT pg_namespace.nspname, pg_proc.proname 
FROM pg_proc, pg_namespace 
WHERE pg_proc.pronamespace=pg_namespace.oid 
AND pg_proc.proname LIKE '%dblink%';


SELECT *
    FROM dblink('host=localhost dbname=Baveria user=postgres password=bolbona options=-csearch_path=','select gid, country from public.baveria_districts')
AS remote_table(gid int, country text);

SELECT dblink_connect('dbname=petascopedb options=-csearch_path=');

SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=postgres password=bolbona options=-csearch_path=','select coverage_id from public.coverage')
AS remote_table(coverage_id text);

SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=','select coverage_id from public.coverage')
AS remote_table(coverage_id text);


SELECT *
    FROM dblink('host=localhost dbname=petascopedb user=petauser password=petapasswd options=-csearch_path=',
	   'SELECT coverage.coverage_id, wgs84_bounding_box.max_lat, wgs84_bounding_box.min_lat, wgs84_bounding_box.max_long, wgs84_bounding_box.min_long 	
		FROM public.coverage
		JOIN public.envelope_by_axis ON  envelope.envelope_by_axis_id = envelope_by_axis.envelope_by_axis_id
		JOIN public.wgs84_bounding_box ON envelope_by_axis.wgs84_bounding_box_id = wgs84_bounding_box.wgs84_bounding_box_id ')
AS remote_table(coverage_id text, max_lat float, min_lat float, max_long float, min_long float);


-- SQL TRIGGER AND LOOKUP Table


CREATE OR REPLACE FUNCTION update_lookup_table()
  RETURNS TRIGGER 
  LANGUAGE PLPGSQL
  AS
$$
BEGIN
	CREATE OR REPLACE VIEW LookUp AS
	SELECT coverage.id, geo_axis.general_grid_id, coverage.coverage_id,  axis_extent.axis_label, axis_extent.axis_type, axis_extent.uom_label AS unit, axis_extent.lower_bound, axis_extent.grid_lower_bound,
		    axis_extent.upper_bound, axis_extent.grid_upper_bound, geo_axis.resolution
	FROM public.coverage, public.envelope,  public.axis_extent, public.geo_axis
	WHERE coverage.envelope_id = envelope.envelope_id 
	AND envelope.envelope_by_axis_id = axis_extent.envelope_by_axis_id 
	AND axis_extent.upper_bound = geo_axis.upper_bound;
 
    RETURN LookUp;	
END;
$$

CREATE TRIGGER update_lookup
AFTER UPDATE ON coverage
EXECUTE PROCEDURE update_lookup_table();


-- MaxLon, MinLat inclusoin in the geo2grid python procedure

SELECT min_long as xmin, max_lat as ymax  FROM lookup_02 WHERE coverage_id = 'Baveria_Temperature_MODIS_1km'

SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Baveria_Temperature_MODIS_1km AS c')) AS avg_temp_°C     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';



SELECT  8.979166665862266 AS minlon, 50.56666666213664 AS maxlat     


SELECT rasdaman_op.query2array('select rasdb[49, 0:2 , 0:2] from Baveria_Temperature_MODIS_1km as rasdb')



SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[100, 0:* , 0:*]),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';

SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[20, 0:* , 0:*]),',rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Linköping';


SELECT  m.name_2 AS region,
        rasdaman_op.query2array(CONCAT('select clip((c[100, 0:* , 0:*]*0.02),',rasdaman_op.geo2grid(ST_AsText((ST_Dump(geom)).geom),8.979166665862266,50.56666666213664),') from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';



SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_coords(ST_AsText((ST_Dump(geom)).geom)) AS Geom   
FROM    region_bavaria as m
WHERE   m.name_2 = 'Deggendorf';


-- FDW

SELECT dblink_connect('host=localhost user=postgres password=bolbona dbname=VectorDB');

CREATE FOREIGN DATA WRAPPER postgres VALIDATOR postgresql_fdw_validator;

CREATE SERVER petascope_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'petascopedb');

CREATE USER MAPPING FOR postgres SERVER petascope_server OPTIONS (schema_name 'public', user 'petauser', password 'bolbona');

GRANT USAGE ON FOREIGN SERVER petascope_server TO postgres;

SELECT dblink_connect('petascopedb');

SELECT * FROM dblink('petascopedb','select envelope_id from envelope');


--PLPYTHON Functions

-- FUNCTION: rasdaman_op.geo2grid_coords(text)

-- DROP FUNCTION IF EXISTS rasdaman_op.geo2grid_coords(text);

CREATE OR REPLACE FUNCTION rasdaman_op.geo2grid_coords(
	"geoPOLY" text,
	OUT "gridPOLY" text)
    RETURNS text
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
import numpy as np
import re
import gdal
from affine import Affine
from shapely.geometry import Polygon
from shapely import wkt

xmin = 10.38333333240314  
ymax = 47.099999995780536 
pixel_size = 0.008333333332586793

def grid2WKT_polygon(y_grid, x_grid):
    coordinates = list(zip(y_grid, x_grid))
    polygon = "POLYGON((" + ", ".join(f"{x} {y}" for x, y in coordinates) + "))"
    return polygon

def geo2grid(lons, lats, xmin, ymax, pixel_size, xskew = 0.0, yskew = 0.0):
    aff_gdal = Affine.from_gdal(xmin, pixel_size, xskew, ymax, 0.0, -pixel_size)
    lons = np.array(lons)
    lats = np.array(lats)
    xs, ys = ~aff_gdal*(lons, lats)
    xs = np.int64(xs)
    ys = np.int64(ys)
    return xs, ys 

def add_closing_coordinates(d):
    i = re.search(r"\d", d).start()
    j = re.search(r'(\d)[^\d]*$', d).start() + 1
    c = d.index(',')    
    return d[:j] + ", " + d[i:c] + d[j:]

def processPOLYGON(inputPOLYGON, regionID = None):
    if inputPOLYGON.area < pixel_size:
	    pass
    elif len(inputPOLYGON.interiors) == 0:
        coords = np.dstack(inputPOLYGON.boundary.xy).tolist()[0][:-1]
        expected_list_of_coordinates_for_received_code = [{"long": x, "lat": y} for x, y in coords]
        lat_arr = []
        long_arr = []
        for i in range(len(expected_list_of_coordinates_for_received_code)):
            long_arr = np.append(long_arr, expected_list_of_coordinates_for_received_code[i]['long'])
            lat_arr = np.append(lat_arr, expected_list_of_coordinates_for_received_code[i]['lat'])

        long_list = long_arr.tolist()
        lat_list = lat_arr.tolist()

        x_grid, y_grid = geo2grid(long_list, lat_list, xmin, ymax, pixel_size)
        gridPOLYGON_yx = grid2WKT_polygon(y_grid, x_grid)

        return gridPOLYGON_yx
    else:
        print(f"{regionID}: Polygon Ring Detected")
        mainPOLYGON = Polygon(inputPOLYGON.exterior)  
        gridPOLYGON_yx = processPOLYGON(mainPOLYGON)

        return gridPOLYGON_yx

           
def geoPOLYGON_to_gridPOLYGON_03(inputREGION, regionID = None):
    polygons_array1 = []
    polygons_array2 = []
    i = 0
    r = 0
    inputREGION = wkt.loads(inputREGION)
    if inputREGION.geom_type == 'Polygon':
        return processPOLYGON(inputREGION, regionID)
    
    elif len(list(inputREGION.geoms[0].interiors)) > 0:         
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array1.append(gridPOLYGON)
            r = r +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array1]
        return shapely.geometry.MultiPolygon(gridMULTI)

    else:                                                  
        print(f"{regionID}: MultiPolygon is processing")
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array2.append(gridPOLYGON)
            i = i +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array2]
        return shapely.geometry.MultiPolygon(gridMULTI)

gridPOLY = geoPOLYGON_to_gridPOLYGON_03(geoPOLY)
return gridPOLY
$BODY$;

ALTER FUNCTION rasdaman_op.geo2grid_coords(text)
    OWNER TO postgres;


-- FUNCTION: rasdaman_op.geo2grid_final(text, double precision, double precision, double precision, double precision)

CREATE OR REPLACE FUNCTION rasdaman_op.geo2grid_final(
	"geoPOLY" text,
	min_lon double precision,
	max_lat double precision,
	resolution_lon double precision,
	resolution_lat double precision,
	OUT "gridPOLY" text)
    RETURNS text
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
import numpy as np
import re
import gdal
from affine import Affine
from shapely.geometry import Polygon
from shapely import wkt

def grid2WKT_polygon(y_grid, x_grid):
    coordinates = list(zip(y_grid, x_grid))
    polygon = "POLYGON((" + ", ".join(f"{x} {y}" for x, y in coordinates) + "))"
    return polygon

def geo2grid(lons, lats, xmin, ymax, x_scale, y_scale, xskew = 0.0, yskew = 0.0):
    aff_gdal = Affine.from_gdal(xmin, x_scale, xskew, ymax, 0.0, -y_scale)
    lons = np.array(lons)
    lats = np.array(lats)
    xs, ys = ~aff_gdal*(lons, lats)
    xs = np.int64(xs)
    ys = np.int64(ys)
    return xs, ys 

def add_closing_coordinates(d):
    i = re.search(r"\d", d).start()
    j = re.search(r'(\d)[^\d]*$', d).start() + 1
    c = d.index(',')    
    return d[:j] + ", " + d[i:c] + d[j:]

def processPOLYGON(inputPOLYGON):
    if inputPOLYGON.area < x_scale:
	    pass
    elif len(inputPOLYGON.interiors) == 0:
        coords = np.dstack(inputPOLYGON.boundary.xy).tolist()[0][:-1]
        expected_list_of_coordinates_for_received_code = [{"long": x, "lat": y} for x, y in coords]
        lat_arr = []
        long_arr = []
        for i in range(len(expected_list_of_coordinates_for_received_code)):
            long_arr = np.append(long_arr, expected_list_of_coordinates_for_received_code[i]['long'])
            lat_arr = np.append(lat_arr, expected_list_of_coordinates_for_received_code[i]['lat'])

        long_list = long_arr.tolist()
        lat_list = lat_arr.tolist()

        x_grid, y_grid = geo2grid(long_list, lat_list, xmin, ymax, x_scale, y_scale)
        gridPOLYGON_yx = grid2WKT_polygon(y_grid, x_grid)

        return gridPOLYGON_yx
    else:
        mainPOLYGON = Polygon(inputPOLYGON.exterior)  
        gridPOLYGON_yx = processPOLYGON(mainPOLYGON)

        return gridPOLYGON_yx

def geoPOLYGON_to_gridPOLYGON_03(inputREGION, min_lon, max_lat, resolution_lon, resolution_lat):
    polygons_array1 = []
    polygons_array2 = []
    i = 0
    r = 0
    global xmin
    xmin = min_lon
    global ymax
    ymax= max_lat
    global x_scale
    x_scale = resolution_lon
    global y_scale
    y_scale = resolution_lat
	
    inputREGION = wkt.loads(inputREGION)
    if inputREGION.geom_type == 'Polygon':
        return processPOLYGON(inputREGION)
    
    elif len(list(inputREGION.geoms[0].interiors)) > 0:         
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array1.append(gridPOLYGON)
            r = r +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array1]
        return shapely.geometry.MultiPolygon(gridMULTI)

    else:                                                  
        for polygon in inputREGION.geoms:
            gridPOLYGON = processPOLYGON(polygon)
            polygons_array2.append(gridPOLYGON)
            i = i +1
            
        gridMULTI =  [shapely.wkt.loads(poly) for poly in polygons_array2]
        return shapely.geometry.MultiPolygon(gridMULTI)	
	
gridPOLY = geoPOLYGON_to_gridPOLYGON_03(geoPOLY, min_lon, max_lat, resolution_lon, resolution_lat)
return gridPOLY
	
           
$BODY$;

ALTER FUNCTION rasdaman_op.geo2grid_final(text, double precision, double precision, double precision, double precision)
    OWNER TO postgres;

	
           
-- FUNCTION: rasdaman_op.query2array(text)

CREATE OR REPLACE FUNCTION rasdaman_op.query2array(
	query text,
	OUT data_array double precision[])
    RETURNS double precision[]
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
from rasdapy.db_connector import DBConnector
from rasdapy.query_executor import QueryExecutor

def query2array(query):
    result = query_executor.execute_read(query) 
    numpy_array = result.to_array()
    return numpy_array.tolist()  
	
db_connector = DBConnector("localhost", 7001, "rasadmin", "rasadmin")
query_executor = QueryExecutor(db_connector)
db_connector.open()

try:
   data_array= query2array(query)
   return data_array
finally:
   db_connector.close()
$BODY$;

ALTER FUNCTION rasdaman_op.query2array(text)
    OWNER TO postgres;


-- FUNCTION: rasdaman_op.query2numeric(text)

-- DROP FUNCTION IF EXISTS rasdaman_op.query2numeric(text);

CREATE OR REPLACE FUNCTION rasdaman_op.query2numeric(
	query text,
	OUT double precision)
    RETURNS double precision
    LANGUAGE 'plpython3u'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
from rasdapy.db_connector import DBConnector
from rasdapy.query_executor import QueryExecutor

def query2result(query):
   output_val = query_executor.execute_read(query)
   output_val = float("{}".format(output_val))
   return output_val
	
db_connector = DBConnector("localhost", 7001, "rasadmin", "rasadmin")
query_executor = QueryExecutor(db_connector)
db_connector.open()

try:
   return float("{:.3f}".format(query2result(query)))
finally:
   db_connector.close()
$BODY$;

ALTER FUNCTION rasdaman_op.query2numeric(text)
    OWNER TO postgres;




-- EXPERIMENTING

SELECT  name_2, geom
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'; --Göteborg Umeå Leksand

SELECT name_1,name_2, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_sweden   -- Multipolygons to polygons
WHERE name_2 in ('Göteborg','Umeå') ;

SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797)     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg'; --Göteborg Umeå Leksand


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select max_cells(clip((c[145, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.958333332351629,69.06666666047931,0.008333333332586788,0.008333333332586788),')) from Surface_Temperature_Sweden AS c')) AS min_temp     
FROM    region_sweden as m
WHERE   m.name_2 = 'Göteborg' LIMIT 1;



-- ###################################################################################################################################################################################################################

SELECT  name_2, geom
FROM    region_bavaria as m
WHERE   m.name_2 = 'Bayreuth'; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Bayreuth'; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797)     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[249, 0:* , 0:*]*0.02)-273.15,',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),8.974999999195973,50.56666666213664,0.00833333333258679,0.008333333332586797),')) from Baveria_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


SELECT  m.name_2, geom AS region
FROM    region_bavaria as m
WHERE   m.name_2 = 'Rosenheim' LIMIT 1; --Würzburg Rosenheim Bayreuth Cham


-- ###################################################################################################################################################################################################################

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Bolzano'; -- Lagundo Racines Senales Bolzano

SELECT name_1,name_2, name_3, length(ST_AsText((ST_Dump(geom)).geom)), ST_AsText((ST_Dump(geom)).geom) FROM region_south_tyrol   -- Multipolygons to polygons
WHERE name_3 ='Bolzano';

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Senales'; -- Lagundo Racines Senales

SELECT  name_3, geom
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Lagundo'; -- Lagundo Racines Senales

SELECT  name_1, name_2, name_3, 
	    rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762)
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Lagundo' LIMIT 1;


SELECT  name_1, name_2, name_3 AS region,
        rasdaman_op.query2numeric(CONCAT('select min_cells(clip((c[283, 0:* , 0:*]),',rasdaman_op.geo2grid_final(ST_AsText((ST_Dump(geom)).geom),10.38333333240314,47.099999995780536,0.008333333332586793,0.008333333332586762),')) from South_Tyrol_Temperature_MODIS_1km AS c')) AS min_temp     
FROM    region_south_tyrol as m
WHERE   m.name_3 = 'Senales' LIMIT 1;



















